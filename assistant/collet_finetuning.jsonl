{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Fetch pull requests for a GitHub repository."}, {"role": "assistant", "content": "{:name      :fetch-github-pulls\n :type      :collet.actions.http/request\n :selectors {owner    [:config :owner]\n             repo     [:config :repo]\n             gh-token [:config :gh-token]}\n :params    {:url         [\"https://api.github.com/repos/%s/%s/pulls\" owner repo]\n             :headers     {\"Accept\"               \"application/vnd.github+json\"\n                           \"X-GitHub-Api-Version\" \"2022-11-28\"}\n             :oauth-token gh-token\n             :as          :json}}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Fetch the users table from a PostgreSQL database."}, {"role": "assistant", "content": "{:name      :fetch-users-table\n :type      :collet.actions.jdbc/query\n :selectors {db-url   [:config :db-url]\n             user     [:config :user]\n             password [:config :password]}\n :params    {:connection {:jdbc-url db-url\n                          :user     user\n                          :password password}\n             :query      [\"SELECT * FROM users\"]}}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Fetch singer albums from an OData API."}, {"role": "assistant", "content": "{:name   :fetch-singer-albums\n :type   :collet.actions.odata/request\n :params {:service-url \"https://music.odata.example.com\"\n          :segment     [:Albums]\n          :filter      [\"singer eq 'Adele'\"]\n          :select      [:AlbumName :ReleaseDate]}\n :return [:body \"value\"]}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Fetch weather data from OpenWeatherMap."}, {"role": "assistant", "content": "{:name      :fetch-weather\n :type      :collet.actions.http/request\n :selectors {city    [:config :city]\n             api-key [:config :owm-api-key]}\n :params    {:url          \"https://api.openweathermap.org/data/2.5/weather\"\n             :query-params {:q city :appid api-key}\n             :method       :get\n             :as           :json}}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Fetch recent commits from GitHub."}, {"role": "assistant", "content": "{:name      :fetch-recent-commits\n :type      :collet.actions.http/request\n :selectors {owner    [:config :owner]\n             repo     [:config :repo]\n             gh-token [:config :gh-token]}\n :params    {:url         [\"https://api.github.com/repos/%s/%s/commits\" owner repo]\n             :headers     {\"Accept\"               \"application/vnd.github+json\"\n                           \"X-GitHub-Api-Version\" \"2022-11-28\"}\n             :oauth-token gh-token\n             :as          :json}}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Fetch open issues from Jira."}, {"role": "assistant", "content": "{:name      :fetch-open-jira-issues\n :type      :collet.actions.http/request\n :selectors {company    [:config :company]\n             username   [:config :username]\n             jira-user  [:config :user]\n             jira-token [:config :jira-creds]}\n :params    {:url          [\"https://%s.atlassian.net/rest/api/3/search\" company]\n             :query-params {:jql [\"assignee=%s AND status=Open\" username]}\n             :basic-auth   [jira-user jira-token]\n             :accept       :json\n             :as           :json}}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Convert a CSV file to a Clojure data structure."}, {"role": "assistant", "content": "{:name   :parse-csv-as-clojure-data\n :type   :custom\n :params [\"data/input.csv\"]\n :fn     '(fn [csv-path]\n            (charred/read-csv (io/as-file csv-path)))}\n"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Store JSON data to AWS S3."}, {"role": "assistant", "content": "{:name      :store-json-to-s3\n :type      :collet.actions.s3/sink\n :selectors {data       [:state :json-data]\n             aws-key    [:config :aws-key]\n             aws-secret [:config :aws-secret]\n             aws-region [:config :aws-region]}\n :params    {:aws-creds {:aws-key    aws-key\n                         :aws-secret aws-secret\n                         :aws-region aws-region}\n             :input     data\n             :format    :json\n             :bucket    \"monthly-reports\"\n             :file-name \"supply-chain/2022-01-01.json\"}}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Store a report as CSV locally."}, {"role": "assistant", "content": "{:name :store-report-locally\n :type :collet.actions.file/sink\n :selectors {report [:state :report-data]}\n :params {:input report\n          :format :csv\n          :file-name \"./reports/report.csv\"\n          :csv-header? true}}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Enrich every dataset item by fetching additional details via HTTP and merging a details-map with original item."}, {"role": "assistant", "content": "{:name      :enrich-dataset\n :type      :enrich\n :target    [:state :dataset]\n :action    :collet.actions.http/request\n :selectors {detail-id [:$enrich/item :detail-id]}\n :params    {:url    [\"https://api.example.com/details/%s\" detail-id]\n             :method :get\n             :as     :json}\n :return    [:body :details-map]}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Iterate over a list of user IDs to fetch user details from API endpoint."}, {"role": "assistant", "content": "{:name     :fetch-user-details\n :inputs   [:user-ids]\n :actions  [{:name      :user-mapper\n             :type      :mapper\n             :selectors {user-ids [:inputs :user-ids]}\n             :params    {:sequence user-ids}}\n            {:name      :fetch-user\n             :type      :collet.actions.http/request\n             :selectors {user-id [:$mapper/item]}\n             :params    {:url    [\"https://api.example.com/users/%s\" user-id]\n                         :method :get\n                         :as     :json}}]\n :iterator {:next [:true? :$mapper/has-next-item]}}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Aggregate sales data and compute statistics."}, {"role": "assistant", "content": "{:name      :compute-sales-stats\n :type      :stats\n :selectors {sales [:state :sales-data]}\n :params    {:sequence sales\n             :metrics  {:total-sales  [:sum :amount]\n                        :average-sale [:mean :amount]\n                        :min-sale     [:min :amount]\n                        :max-sale     [:max :amount]}}}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Write a message to a Chronicle queue."}, {"role": "assistant", "content": "{:name   :enqueue-messages\n :type   :collet.actions.queue/enqueue\n :params {:input      {:message \"Test message\"}\n          :queue-name :message-queue}}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Apply a JSLT transformation to reformat JSON data."}, {"role": "assistant", "content": "{:name      :apply-jslt\n :type      :collet.actions.jslt/apply\n :selectors {orders [:state orders-raw]}\n :params    {:input    orders\n             :template \"[for(.)\n                         {\n                           \\\"order_id\\\": .order_id,\n                           \\\"customer_name\\\": .customer.name,\n                           \\\"total_items\\\": size(.order.items),\n                           \\\"total_cost\\\": sum([for (.order.items) .price * .quantity])\n                         }]\"}}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Perform the request to OAuth2 endpoint to get the auth token."}, {"role": "assistant", "content": "{:name      :get-oauth2-token\n :type      :collet.actions.http/oauth2\n :selectors {client-id     [:config :client-id]\n             client-secret [:config :client-secret]\n             scope         [:config :scope]}\n :params    {:url           \"https://example.com/oauth2/token\"\n             :client-id     client-id\n             :client-secret client-secret\n             :grant-type    scope}\n :return    [:body :access_token]}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Make a rate-limited HTTP request."}, {"role": "assistant", "content": "{:name   :rate-limited-request\n :type   :collet.actions.http/request\n :params {:url    \"https://api.example.com/data\"\n          :method :get\n          :rate   2\n          :as     :json}}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Run a custom action to calculate a price discount."}, {"role": "assistant", "content": "{:name      :calculate-discount\n :type      :custom\n :selectors {price [:state :price]}\n :params    [price]\n :fn        '(fn [price] \n               (* price 0.9))}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Create a task to fetch paginated data from a REST API. Take 10 first pages."}, {"role": "assistant", "content": "{:name     :fetch-paginated-data\n :actions  [{:name   :page-counter\n             :type   :counter\n             :params {:start 1 :step 1}}\n            {:name      :fetch-page\n             :type      :collet.actions.http/request\n             :selectors {page [:state :page-counter]}\n             :params    {:url          \"https://api.example.com/items\"\n                         :query-params {:page page :per_page 50}\n                         :method       :get\n                         :as           :json}}]\n :iterator {:next [:< [:state :req-count] 10]}}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Generate a greeting using clj/format."}, {"role": "assistant", "content": "{:name      :generate-greeting\n :type      :clj/format\n :selectors {name [:config :user-name]}\n :params    [\"Hello, %s!\" name]}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Fetch products from an OData service."}, {"role": "assistant", "content": "{:name   :fetch-products\n :type   :collet.actions.odata/request\n :params {:service-url \"https://odata.example.com\"\n          :segment     [:Products]\n          :select      [:ProductName :Price]}\n :return [:body \"value\"]}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Insert new products record or update existing based on the state."}, {"role": "assistant", "content": "{:name      :insert-or-update\n :type      :switch\n :selectors {jdbc-url [:config :jdbc-url]\n             pg-user  [:config :pg-user]\n             pg-pass  [:config :pg-pass]}\n :case      [{:condition [:nil? [:state :query-action :record]]\n              :actions   [{:name      :insert-record\n                           :type      :collet.actions.jdbc/execute\n                           :selectors {product-record [:state :query-action :record]}\n                           :params    {:connection {:jdbcUrl  jdbc-url\n                                                    :user     pg-user\n                                                    :password pg-pass}\n                                       :statement  {:insert-into [:products]\n                                                    :columns     [:product :description :price]\n                                                    :values      [product-record]}}}]}\n             {:condition :default\n              :actions   [{:name      :update-record\n                           :type      :collet.actions.jdbc/execute\n                           :selectors {description [:state :query-action :record :description]\n                                       price       [:state :query-action :record :price]\n                                       product     [:state :query-action :record :product]}\n                           :params    {:connection {:jdbcUrl  jdbc-url\n                                                    :user     pg-user\n                                                    :password pg-pass}\n                                       :statement  {:update :products\n                                                    :set    {:description description\n                                                             :price       price}\n                                                    :where  [:= :product product]}}}]}]}\n"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Flatten nested JSON data."}, {"role": "assistant", "content": "{:name      :flatten-json\n :type      :slicer\n :selectors {data [:state :nested-json]}\n :params    {:sequence data\n             :apply    [[:flatten {:by {:field [:nested-field [:$/cat :even-more-nested-field]]}}]]}}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Group sales data by region."}, {"role": "assistant", "content": "{:name      :group-sales-by-region\n :type      :slicer\n :selectors {sales [:state :sales]}\n :params    {:sequence sales\n             :apply    [[:group {:by :region}]]}}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Join customer and orders datasets."}, {"role": "assistant", "content": "{:name      :join-customer-orders\n :type      :slicer\n :selectors {customers [:state :customers]\n             orders    [:state :orders]}\n :params    {:sequence customers\n             :apply    [[:join {:with   orders\n                                :source :customer_id\n                                :target [:customer :id]}]]}}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Enrich a dataset with external API data."}, {"role": "assistant", "content": "{:name      :enrich-records\n :type      :enrich\n :target    [:state :records]\n :action    :collet.actions.http/request\n :selectors {record-id [:$enrich/item :id]}\n :params    {:url [\"https://api.example.com/record/%s\" record-id]\n             :as  :json}\n :return    [:body :detail]\n :fold-in   [:detail]}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Get the latest (for last week) orders from Shopify, enrich each order with details related to the products inside the order from PostgreSQL products table, group orders per customer, and store orders as CSV file in S3 individually for each customer."}, {"role": "assistant", "content": "{:name  :shopify-orders-pipeline\n :deps  {:coordinates [[io.velio/collet-actions \"0.2.7\"]\n                       [org.postgresql/postgresql \"42.7.3\"]]\n         :requires    [[next.jdbc.types :as types]]}\n \n :tasks [{:name         :shopify-orders\n          :setup        [{:name   :created-time-range\n                          :type   :intervals\n                          :params {:from [:week :ago]\n                                   :to   :today}}]\n          :actions      [{:name :orders\n                          :type :switch\n                          :case [{:condition [:not-nil? [:state :next-link]]\n                                  :actions   [{:name      :fetch-orders\n                                               :type      :collet.actions.http/request\n                                               :selectors {next-link    [:state :next-link]\n                                                           access-token [:config :shopify-access-token]}\n                                               :params    {:url     next-link\n                                                           :headers {\"X-Shopify-Access-Token\" access-token}\n                                                           :as      :json}\n                                               :return    [{:orders      [:body :orders]\n                                                            :link-header [:headers :link]}]}]}\n                                 {:condition :default\n                                  :actions   [{:name      :fetch-orders\n                                               :type      :collet.actions.http/request\n                                               :selectors {access-token [:config :shopify-access-token]\n                                                           created-from [:state :created-time-range :from]\n                                                           created-to   [:state :created-time-range :to]}\n                                               :params    {:url          \"https://your-development-store.myshopify.com/admin/api/2025-01/orders.json\"\n                                                           :headers      {\"X-Shopify-Access-Token\" access-token}\n                                                           :query-params {:status         \"any\"\n                                                                          :created_at_min created-from\n                                                                          :created_at_max created-to}\n                                                           :as           :json}\n                                               :return    [{:orders      [:body :orders]\n                                                            :link-header [:headers :link]}]}]}]}\n                         {:name      :next-link\n                          :type      :clj/re-find\n                          :when      [:not-nil? [:state :fetch-orders :link-header]]\n                          :selectors {link-header [:state :fetch-orders :link-header]}\n                          :params    [#rgx \"<([^>]+)>;\\\\s*rel=next\" link-header]\n                          :return    [[:$/op :first]]}]\n          :iterator     {:next [:not-nil? [:state :next-link]]}\n          :return       [:state :fetch-orders]\n          :state-format :flatten}\n\n         {:name     :enriched-orders\n          :inputs   [:shopify-orders]\n          :actions  [{:name      :orders-details\n                      :type      :enrich\n                      :target    [:inputs :shopify-orders]\n                      :when      [:not-empty? [:$enrich/item :line_items]]\n                      :action    :collet.actions.jdbc/query\n                      :selectors {product-ids [:$enrich/item :line_items [:$/cat :product_id]]\n                                  db-url      [:config :db-url]\n                                  db-user     [:config :db-user]\n                                  db-password [:config :db-password]}\n                      :params    {:connection {:jdbc-url db-url\n                                               :user     db-user\n                                               :password db-password}\n                                  :query      [\"SELECT * FROM products WHERE id = ANY(?)\"\n                                               (types/int-array product-ids)]}\n                      :fold-in   [:line_items [:= :product_id :id]]}]\n          :iterator {:next [:true? [:$enrich/has-next-item]]}}\n\n         {:name    :customer-orders\n          :inputs  [:enriched-orders]\n          :actions [{:name   :group-by-customer\n                     :type   :slicer\n                     :params {:sequence [:inputs :enrich-orders]\n                              :apply    [[:group {:by          [:customer :id]\n                                                  :join-groups false}]]}}]}\n\n         {:name     :store-report\n          :inputs   [:customer-orders]\n          :setup    [{:name      :customers-orders-seq\n                      :type      :clj/vals\n                      :selectors {all-customers-orders [:inputs :customer-orders]}\n                      :params    [all-customers-orders]}]\n          :actions  [{:name      :customer-orders\n                      :type      :mapper\n                      :selectors {customer-orders [:state :customers-orders-seq]}\n                      :params    {:sequence customer-orders}}\n                     {:name      :customer-report-file\n                      :type      :clj/format\n                      :selectors {customer-id [:$mapper/item :customer :id]}\n                      :params    [\"reports/orders-per-customer/%s.csv\" customer-id]}\n                     {:name      :s3-sink\n                      :type      :collet.actions.s3/sink\n                      :selectors {bucket     [:config :s3-bucket]\n                                  aws-key    [:config :aws-key]\n                                  aws-secret [:config :aws-secret]\n                                  aws-region [:config :aws-region]\n                                  data       [:$mapper/item]\n                                  file-name  [:state :customer-report-file]}\n                      :params    {:aws-creds   {:aws-key    aws-key\n                                                :aws-secret aws-secret\n                                                :aws-region aws-region}\n                                  :format      :csv\n                                  :input       data\n                                  :bucket      bucket\n                                  :file-name   file-name\n                                  :csv-header? true}}]\n          :iterator {:next [:true? [:$mapper/has-next-item]]}}]}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Download financial transactions (charges) from Stripe API, within a specified time window, perform a fraud detection based on their deviation from the norm using a Local Outlier Factor (LOF) algorithm, and save suspicious transactions locally CSV format."}, {"role": "assistant", "content": "{:name  :stripe-transactions-task\n :deps  {:coordinates [[io.velio/collet-actions \"0.2.7\"]\n                       [com.github.haifengl/smile-core \"4.3.0\"]]\n         :requires    [[java-time.api :as jt]]\n         :imports     [smile.outlier.LOF\n                       smile.math.distance.EuclideanDistance]}\n\n :tasks [{:name     :stripe-:charges\n          :setup    [{:name   :time-interval-timestamp\n                      :type   :intervals\n                      :params {:from   :yesterday\n                               :to     :now\n                               :format :epoch}}\n                     {:name :time-interval\n                      :type :custom\n                      :fn   (fn [{:keys [from to]}]\n                              {:from (long (/ from 1000))\n                               :to   (long (/ to 1000))})}]\n\n          :actions  [{:name      :charges\n                      :type      :collet.actions.http/request\n                      :selectors {api-key     [:config :stripe-api-key]\n                                  customer-id [:config :customer-id]\n                                  from        [:state :time-interval :from]\n                                  to          [:state :time-interval :to]\n                                  latest-id   [:state :charges :latest-id]}\n                      :params    {:url          \"https://api.stripe.com/v1/charges\"\n                                  :oauth-token  api-key\n                                  :query-params {:customer       customer-id\n                                                 :limit          100\n                                                 :created        {:gte from :lte to}\n                                                 :starting_after latest-id}\n                                  :as           :json}\n                      :return    [{:charges   [:body :data [:$/cat {:id :id :amount :amount :created :created}]]\n                                   :latest-id [:dody :data [:$/op :last] :id]\n                                   :has_more  [:body :has_more]}]}]\n          :iterator {:next [:true? :charges :has_more]}\n          :return   [[:$/cat :charges]]}\n\n         {:name    :fraud-charges\n          :inputs  [:stripe-:charges]\n          :setup   [{:name :smile-lof\n                     :type :custom\n                     :fn   (fn []\n                             (LOF. data 3 (EuclideanDistance.)))}]\n          :actions [{:name      :fraud\n                     :type      :slicer\n                     :selectors {charges [:inputs :stripe-:charges]\n                                 lof     [:state :smile-lof]}\n                     :params    {:sequence charges\n                                 :apply    [[:map {:with (fn [{:keys [amount created]} lof]\n                                                           (let [hour (-> (jt/instant (* created 1000))\n                                                                        (jt/zoned-date-time \"UTC\")\n                                                                        (jt/as :hour-of-day))\n                                                                 row (double-array [amount hour])]\n                                                             {:lof-score (.score lof row)}))\n                                                   :args [lof]}]\n                                            [:filter {:by [:> :lof-score 1.5]}]]}}\n                    {:name      :local-file-sink\n                     :type      :collet.actions.file/sink\n                     :selectors {data [:inputs :fraud]}\n                     :params    {:input     data\n                                 :format    :csv\n                                 :file-name \"./reports/suspicious_transactions.csv\"}}]}]}"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Generate a workflow designed to gather data from a GitHub organization and generate reports on developer productivity. It should retrieve the list of all repositories and related pull request information, then calculate and saves various metrics on the per user basis like total pull requests, merge ratios, monthly pull request counts, and average time to merge."}, {"role": "assistant", "content": "{:name  :devs-productivity-pipeline\n ;; add extra dependencies\n :deps  {:coordinates [[io.velio/collet-actions \"0.2.7\"]]\n         :imports     [java.lang.Math\n                       java.time.LocalDate\n                       java.time.LocalDateTime\n                       java.time.format.DateTimeFormatter\n                       java.time.temporal.ChronoUnit]}\n ;; specify the list of tasks\n :tasks [;; get the list of repositories for the organization\n         {:name     :repositories\n          :actions  [{:name :paginate-or-request\n                      :type :switch\n                      :case [{:condition [:not-nil? [:state :next-page-link]]\n                              ;; request the next page\n                              :actions   [{:name      :repositories-request\n                                           :type      :collet.actions.http/request\n                                           :selectors {next-page [:state :next-page-link]\n                                                       gh-token  [:config :gh-token]}\n                                           :params    #include [\"./gh-request.edn\" {:url next-page}]\n                                           :return    [{:repos [:body]\n                                                        :link  [:headers :link]}]}]}\n                             {:condition :default\n                              ;; do initial request\n                              :actions   [{:name      :repositories-request\n                                           :type      :collet.actions.http/request\n                                           :selectors {gh-token [:config :gh-token]\n                                                       org-name [:config :org-name]}\n                                           :params    #include [\"./gh-request.edn\"\n                                                                {:url          [\"https://api.github.com/orgs/%s/repos\" org-name]\n                                                                 :query-params {:per_page 100}}]\n                                           :return    [{:repos [:body]\n                                                        :link  [:headers :link]}]}]}]}\n                     ;; parse the next page link from previous request\n                     {:name      :next-page-link\n                      :type      :clj/re-find\n                      :when      [:not-nil? [:state :repositories-request :link]]\n                      :selectors {next-link [:state :repositories-request :link]}\n                      :params    [#rgx \"(?<=<)([\\\\S]*)(?=>; rel=\\\"next\\\")\" next-link]\n                      :return    [[:$/op :first]]}]\n          ;; proceed while there is a next page link\n          :iterator {:next [:not-nil? [:state :next-page-link]]}\n          :return   [:state :repositories-request :repos [:$/cat #include \"./repo-keys.edn\"]]}\n\n         ;; get the list of pull requests for each repository\n         {:name     :pull-requests\n          :inputs   [:repositories]\n          :actions  [{:name :paginate-or-request\n                      :type :switch\n                      :case [{:condition [:nil? [:state :repository-prs :link]]\n                              ;; take the repo from list and make initial request for PRs\n                              :actions   [{:name      :repository\n                                           :type      :mapper\n                                           :selectors {repos [:inputs :repositories]}\n                                           :params    {:sequence repos}}\n                                          {:name      :repository-prs\n                                           :type      :collet.actions.http/request\n                                           :selectors {gh-token [:config :gh-token]\n                                                       org-name [:config :org-name]\n                                                       repo     [:$mapper/item :name]}\n                                           :params    #include [\"./gh-request.edn\"\n                                                                {:url          [\"https://api.github.com/repos/%s/%s/pulls\" org-name repo]\n                                                                 :query-params {:per_page 100 :state \"closed\"}}]\n                                           :return    [{:prs  [:body]\n                                                        :link [:headers :link]}]}]}\n                             {:condition [:regex [:state :repository-prs :link] \".*rel=\\\"next\\\".*\"]\n                              ;; get the next page of PRs\n                              :actions   [{:name      :next-page-link\n                                           :type      :clj/re-find\n                                           :selectors {next-link [:state :repository-prs :link]}\n                                           :params    [#rgx \"(?<=<)([\\\\S]*)(?=>; rel=\\\"next\\\")\" next-link]\n                                           :return    [[:$/op :first]]}\n                                          {:name      :repository-prs\n                                           :type      :collet.actions.http/request\n                                           :selectors {next-page [:state :next-page-link]\n                                                       gh-token  [:config :gh-token]}\n                                           :params    #include [\"./gh-request.edn\"\n                                                                {:url next-page}]\n                                           :return    [{:prs  [:body]\n                                                        :link [:headers :link]}]}]}\n                             {:condition :default\n                              ;; no more PRs for the particular repo, clear the state and proceed to the next repo\n                              :actions   [{:name   :repository-prs\n                                           :type   :clj/identity\n                                           :params {:prs [] :link nil}}]}]}]\n          ;; proceed while there is a next page link or there are more repositories\n          :iterator {:next [:or [:not-nil? [:state :repository-prs :link]]\n                            [:true? [:$mapper/has-next-item]]]}\n          :return   [:state :repository-prs :prs [:$/cat #include \"./pr-keys.edn\"]]}\n\n         ;; generate productivity reports\n         ;; calculate the total number of PRs for each member across all repositories\n         {:name    :total-prs-by-member\n          :inputs  [:pull-requests]\n          :actions [{:name      :prs-by-member\n                     :type      :slicer\n                     :selectors {pulls [:inputs :pull-requests]}\n                     :params    {:sequence pulls\n                                 :apply    [[:fold {:by      :user-id\n                                                    :columns {:pulls-count [:count-distinct :id]}}]\n                                            [:select {:columns [:user-id :pulls-count]}]]}}\n                    {:name      :save-total-report\n                     :type      :collet.actions.file/sink\n                     :selectors {data [:state :prs-by-member]}\n                     :params    {:input       data\n                                 :format      :csv\n                                 :csv-header? true\n                                 :file-name   \"./reports/total-prs-by-member.csv\"}}]}\n\n         ;; calculate the merge ratio for each member\n         {:name    :merge-ratio-by-member\n          :inputs  [:pull-requests]\n          :actions [{:name      :merge-ratios\n                     :type      :slicer\n                     :selectors {pulls [:inputs :pull-requests]}\n                     :params    {:sequence pulls\n                                 :apply    [[:fold {:by      :user-id\n                                                    :columns {:merged-count [:count-distinct :merged_at]\n                                                              :total-count  [:count-distinct :id]}}]\n                                            [:map {:with (fn [{:keys [merged-count total-count]}]\n                                                           {:merge-ratio (Math/round\n                                                                           (* (double (/ merged-count total-count))\n                                                                             100))})}]\n                                            [:select {:columns [:user-id :merge-ratio]}]]}}\n                    {:name      :save-merge-ratio-report\n                     :type      :collet.actions.file/sink\n                     :selectors {data [:state :merge-ratios]}\n                     :params    {:input       data\n                                 :format      :csv\n                                 :csv-header? true\n                                 :file-name   \"./reports/merge-ratio-by-member.csv\"}}]}\n\n         ;; calculate the number of PRs for each member per month\n         {:name    :monthly-prs-by-member\n          :inputs  [:pull-requests]\n          :actions [{:name      :prs-by-member\n                     :type      :slicer\n                     :selectors {pulls [:inputs :pull-requests]}\n                     :params    {:sequence pulls\n                                 :apply    [[:map {:with (fn [{:keys [^String closed_at]}]\n                                                           (let [formatter (DateTimeFormatter/ofPattern \"yyyy-MM-dd'T'HH:mm:ss'Z'\")\n                                                                 dt ^LocalDate (LocalDate/parse closed_at formatter)]\n                                                             {:year-month (str (.getYear dt) \"-\" (.getMonthValue dt))}))}]\n                                            [:fold {:by      [:user-id :year-month]\n                                                    :columns {:pulls-count [:count-distinct :id]}}]\n                                            [:select {:columns [:user-id :pulls-count :year-month]}]]}}\n                    {:name      :save-monthly-report\n                     :type      :collet.actions.file/sink\n                     :selectors {data [:state :prs-by-member]}\n                     :params    {:input       data\n                                 :format      :csv\n                                 :csv-header? true\n                                 :file-name   \"./reports/monthly-prs-by-member.csv\"}}]}\n\n         ;; calculate average time to merge\n         {:name    :average-time-to-merge\n          :inputs  [:pull-requests]\n          :actions [{:name      :time-to-merge\n                     :type      :slicer\n                     :selectors {pulls [:inputs :pull-requests]}\n                     :params    {:sequence pulls\n                                 :apply    [[:map {:with (fn [{:keys [^String created_at ^String merged_at]}]\n                                                           (if (and (not-empty created_at) (not-empty merged_at))\n                                                             (let [formatter (DateTimeFormatter/ofPattern \"yyyy-MM-dd'T'HH:mm:ss'Z'\")\n                                                                   created ^LocalDateTime (LocalDateTime/parse created_at formatter)\n                                                                   merged ^LocalDateTime (LocalDateTime/parse merged_at formatter)]\n                                                               {:time-to-merge (.until created merged ChronoUnit/SECONDS)})\n                                                             {:time-to-merge 0}))}]\n                                            [:filter {:by [:not= :time-to-merge 0]}]\n                                            [:fold {:by      :user-id\n                                                    :columns {:time-to-merge :sum\n                                                              :total-prs     [:count-distinct :id]}}]\n                                            [:map {:with (fn [{:keys [time-to-merge total-prs]}]\n                                                           {:average-ttm (int (/ time-to-merge total-prs))})}]\n                                            [:select {:columns [:user-id :average-ttm]}]]}}\n                    {:name      :save-average-time\n                     :type      :collet.actions.file/sink\n                     :selectors {data [:state :time-to-merge]}\n                     :params    {:input       data\n                                 :format      :csv\n                                 :csv-header? true\n                                 :file-name   \"./reports/average-time-to-merge.csv\"}}]}]}\n\n"}]}
{"messages": [{"role": "system", "content": "You generate Collet actions and tasks in EDN format without additional explanations."}, {"role": "user", "content": "Generate a workflow designed to automatically extract information from product images found in an RSS feed and store the metadata in a database. It retrieves RSS feed items, downloads product images from the URLs found in the feed, uploads the images to an S3 bucket, generates image descriptions and keywords using an LLM, and finally stores the image metadata in a PostgreSQL database."}, {"role": "assistant", "content": "{:name  :image-object-detection\n :deps  {:coordinates [[io.velio/collet-actions \"0.2.7\"]\n                       [remus/remus \"0.2.4\"]\n                       [enlive \"1.1.6\"]]\n         :requires    [[clojure.string :as string]\n                       [remus :as remus]\n                       [net.cgrand.enlive-html :as enlive]]}\n\n :tasks [;; read RSS feed and parse items\n         {:name    :rss-items\n          :actions [{:name      :rss-feed-stream\n                     :type      :collet.actions.http/request\n                     :selectors {feed-url [:config :rss-url]}\n                     :params    {:url     feed-url\n                                 :headers {\"User-Agent\" \"Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1\"}\n                                 :as      :stream}\n                     :return    [:body]}\n                    {:name      :rss-feed\n                     :type      :custom\n                     :selectors {rss-stream [:state :rss-feed-stream]}\n                     :params    [rss-stream]\n                     :fn        (fn [rss-stream]\n                                  (remus/parse-stream rss-stream))\n                     :return    [:entries]}]}\n\n         ;; get product HTML page, find the product image url and store it locally\n         {:name     :image-objects\n          :inputs   [:rss-items]\n          :parallel {:items   [:inputs :rss-items]\n                     :threads 8}\n          :actions  [{:name      :product-page\n                      :type      :collet.actions.http/request\n                      :selectors {page-url [:$parallel/item :uri]}\n                      :params    {:url     page-url\n                                  :headers {\"User-Agent\" \"Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1\"}\n                                  :as      :stream\n                                  :rate    4}\n                      :return    [:body]}\n                     {:name      :product-image-url\n                      :type      :custom\n                      :when      [:not-nil? [:state :product-page]]\n                      :selectors {page-body [:state :product-page]}\n                      :params    [page-body]\n                      :fn        (fn [page-body]\n                                   (let [html (enlive/html-resource page-body)\n                                         image (or (not-empty (enlive/select html [:figure.single-image :img]))\n                                                 (not-empty (enlive/select html [:div#product-image :img])))\n                                         image-url (-> image first (get-in [:attrs :src]))\n                                         image-name (-> (string/split image-url (re-pattern \"/\")) last)]\n                                     {:image-url  image-url\n                                      :image-name image-name}))}\n                     {:name      :product-image\n                      :type      :collet.actions.file/sink\n                      :selectors {image-url  [:state :product-image-url :image-url]\n                                  image-name [:state :product-image-url :image-name]}\n                      :params    {:format          :jpeg\n                                  :folder          \"tmp\"\n                                  :input           image-url\n                                  :file-name       image-name\n                                  :request-options {:headers {\"User-Agent\" \"Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1\"}}}}]\n          :return   [{:image-url  [:state :product-image-url :image-url]\n                      :image-name [:state :product-image-url :image-name]\n                      :local-path [:state :product-image :path]}]}\n\n         ;; upload images to S3\n         {:name     :s3-objects\n          :inputs   [:image-objects]\n          :parallel {:items   [:inputs :image-objects]\n                     :threads 4}\n          :actions  [{:name      :s3-image\n                      :type      :collet.actions.s3/sink\n                      :selectors {image-name [:$parallel/item :image-name]\n                                  local-path [:$parallel/item :local-path]\n                                  aws-region [:config :aws-region]\n                                  aws-key    [:config :aws-key]\n                                  aws-secret [:config :aws-secret]\n                                  bucket     [:config :s3-bucket]}\n                      :params    {:aws-creds {:aws-region        aws-region\n                                              :aws-key           aws-key\n                                              :aws-secret        aws-secret\n                                              ;; this required only for localstack container\n                                              :endpoint-override {:protocol :http\n                                                                  :hostname \"localhost\"\n                                                                  :port     4566}}\n                                  :bucket    bucket\n                                  :file-name image-name\n                                  :input     local-path}}]\n          :return   [{:image-name [:$parallel/item :image-name]\n                      :s3-path    [:state :s3-image :key]}]}\n\n         ;; generate objects keywords in images and short description\n         {:name     :image-keywords\n          :inputs   [:image-objects]\n          :parallel {:items   [:inputs :image-objects]\n                     :threads 4}\n          :actions  [{:name      :llm-inference\n                      :type      :collet.actions.llm/openai\n                      :selectors {product-image  [:$parallel/item :local-path]\n                                  openai-api-key [:config :openai-api-key]}\n                      :params    {:api-key         openai-api-key\n                                  :question        \"Generate a short description of a given image and a set of keywords best describing the given image and objects presented.\"\n                                  :images          [product-image]\n                                  :response-format {:name   \"image-description-and-objects\"\n                                                    :schema [:map\n                                                             [:description :string]\n                                                             [:keywords [:vector :string]]]}}}]\n          :return   [{:image-name  [:$parallel/item :image-name]\n                      :description [:state :llm-inference :description]\n                      :keywords    [:state :llm-inference :keywords]}]}\n\n         ;; store image metadata\n         {:name    :image-metadata-record\n          :inputs  [:s3-objects :image-keywords]\n          :actions [{:name      :metadata-dataset\n                     :type      :slicer\n                     :selectors {s3-objects     [:inputs :s3-objects]\n                                 image-keywords [:inputs :image-keywords]}\n                     :params    {:sequence s3-objects\n                                 :apply    [[:join {:with   image-keywords\n                                                    :source :image-name\n                                                    :target :image-name}]\n                                            [:select {:columns [:image-name :s3-path :description :keywords]}]\n                                            [:map {:with (fn [{:keys [keywords]}]\n                                                           {:keywords (into-array String keywords)})}]]}}\n\n                    {:name      :image-metadata-request\n                     :type      :collet.actions.jdbc/execute\n                     :selectors {products-meta [:state :metadata-dataset]\n                                 jdbc-url      [:config :jdbc-url]\n                                 pg-user       [:config :pg-user]\n                                 pg-pass       [:config :pg-pass]}\n                     :params    {:connection {:jdbcUrl  jdbc-url\n                                              :user     pg-user\n                                              :password pg-pass}\n                                 :statement  {:insert-into [:product-image-meta]\n                                              :columns     [:product :image-path :description :keywords]\n                                              :values      products-meta}}}]}]}"}]}